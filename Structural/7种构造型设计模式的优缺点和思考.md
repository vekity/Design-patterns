# 结构型设计模式

目录

1. [Facade](#facade)  
2. [Proxy](#proxy)  
3. [Adapter](#adapter)  
4. [Bridge](#bridge)  
5. [Composite](#composite)  
6. [Decorator](#decorator)  
7. [Flyweight](#flyweight)  
8. [决策树](#决策树)  
9. [口诀记忆](#口诀)

---

## 1. Facade 门面模式

| 一句话定位   | 给复杂子系统一个统一门面               |
| ------------ | -------------------------------------- |
| **典型坑**   | 调用链 4-5 层，到处 new 子系统         |
| **填坑代码** | `new OrderFacade().createOrder("sku")` |

### 最小可运行示例

```java
// 子系统
class Inventory {
    boolean check(String sku) { return true; }
}
class Order {
    String create() { return "orderId"; }
}
class Payment {
    boolean pay(String oid) { return true; }
}

// Facade
public class OrderFacade {
    private final Inventory inv = new Inventory();
    private final Order ord = new Order();
    private final Payment pay = new Payment();

    public boolean createOrder(String sku) {
        return inv.check(sku) && pay.pay(ord.create());
    }
}

public class FacadeDemo {
    public static void main(String[] args) {
        boolean ok = new OrderFacade().createOrder("sku123");
        System.out.println("下单成功？" + ok);
    }
}
```

## 2. Proxy 代理模式

表格

复制

| 一句话定位   | 给对象加壳做控制 / 延迟                 |
| :----------- | :-------------------------------------- |
| **典型坑**   | 大对象/远程/权限细节泄露                |
| **填坑代码** | `ReportService rs = new ReportProxy();` |

### 最小可运行示例

java

复制

```java
public interface ReportService {
    String data();
}

class HeavyReportService implements ReportService {
    HeavyReportService() { /* 5s IO */ }
    public String data() { return "big data"; }
}

public class ReportProxy implements ReportService {
    private volatile ReportService real;

    public String data() {
        if (real == null) {
            synchronized (this) {
                if (real == null) real = new HeavyReportService();
            }
        }
        return real.data();
    }
}
```

------

## 3. Adapter 适配器模式

表格

复制

| 一句话定位   | 让老接口说新语言                                    |
| :----------- | :-------------------------------------------------- |
| **典型坑**   | if/else 转换逻辑爆炸                                |
| **填坑代码** | `MediaPlayer mp = new Mp4Adapter(new Mp3Player());` |

### 最小可运行示例

java

复制

```java
interface MediaPlayer { void play(String file); }

class Mp3Player {
    void playMp3(String f) { System.out.println("Play mp3 " + f); }
}

class Mp4Adapter implements MediaPlayer {
    private final Mp3Player adaptee = new Mp3Player();
    public void play(String file) { adaptee.playMp3(file); }
}
```

------

## 4. Bridge 桥接模式

表格

复制

| 一句话定位   | 拆维度防 M×N 子类                          |
| :----------- | :----------------------------------------- |
| **典型坑**   | 抽象 × 实现交叉爆炸                        |
| **填坑代码** | `Shape s = new Circle(new RedRenderer());` |

### 最小可运行示例

java

复制

```java
interface Shape { void draw(); }
interface Renderer { void render(); }

class Circle implements Shape {
    private final Renderer renderer;
    Circle(Renderer r) { this.renderer = r; }
    public void draw() { renderer.render(); System.out.print("Circle"); }
}

class RedRenderer implements Renderer {
    public void render() { System.out.print("Red "); }
}
```

------

## 5. Composite 组合模式

表格

复制

| 一句话定位   | 把树当单个对象                     |
| :----------- | :--------------------------------- |
| **典型坑**   | instanceof 判断叶子/容器           |
| **填坑代码** | `folder.add(file); folder.size();` |

### 最小可运行示例

java

复制

```java
interface FileSystem {
    long size();
    default void add(FileSystem f) { throw new UnsupportedOperationException(); }
}

class File implements FileSystem {
    private final long bytes;
    File(long b) { this.bytes = b; }
    public long size() { return bytes; }
}

class Folder implements FileSystem {
    private final List<FileSystem> children = new ArrayList<>();
    public void add(FileSystem f) { children.add(f); }
    public long size() { return children.stream().mapToLong(FileSystem::size).sum(); }
}
```

------

## 6. Decorator 装饰模式

表格

复制

| 一句话定位   | 运行时套娃加功能                                      |
| :----------- | :---------------------------------------------------- |
| **典型坑**   | 继承层级爆炸                                          |
| **填坑代码** | `Coffee c = new Sugar(new Milk(new SimpleCoffee()));` |

### 最小可运行示例

java

复制

```java
interface Coffee { double cost(); }

class SimpleCoffee implements Coffee {
    public double cost() { return 1.0; }
}

abstract class CoffeeDecorator implements Coffee {
    protected final Coffee delegate;
    CoffeeDecorator(Coffee d) { this.delegate = d; }
    public double cost() { return delegate.cost(); }
}

class Milk extends CoffeeDecorator {
    Milk(Coffee c) { super(c); }
    public double cost() { return super.cost() + 0.3; }
}

class Sugar extends CoffeeDecorator {
    Sugar(Coffee c) { super(c); }
    public double cost() { return super.cost() + 0.1; }
}
```

------

## 7. Flyweight 享元模式

表格

复制

| 一句话定位   | 共享百万小对象                         |
| :----------- | :------------------------------------- |
| **典型坑**   | 内存爆掉                               |
| **填坑代码** | `CharGlyph g = GlyphFactory.get('a');` |

### 最小可运行示例

java

复制

```java
final class CharGlyph {
    private final char c;
    CharGlyph(char c) { this.c = c; }
    void draw(int pos) { System.out.print(c); }
}

class GlyphFactory {
    private final CharGlyph[] pool = new CharGlyph[128];
    CharGlyph get(char c) {
        int idx = c;
        if (pool[idx] == null) pool[idx] = new CharGlyph(c);
        return pool[idx];
    }
}
```

------

## 8. 决策树



复制

```
需求 →
├─ 想简化复杂子系统 → Facade
├─ 想控制/延迟对象 → Proxy
├─ 想适配旧接口 → Adapter
├─ 想拆维度防爆炸 → Bridge
├─ 想把树当整体 → Composite
├─ 想运行期加功能 → Decorator
└─ 想省内存大量小对象 → Flyweight
```

------

## 9. 口诀记忆

> **门面简化，代理控制，适配翻译，桥接拆维，组合树化，装饰套娃，享元省内存。**
